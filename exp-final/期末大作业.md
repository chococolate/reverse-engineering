# 期末大作业



## 实验环境

* Visual Studio 2019 

* Win10 

  

## 实验要求

+ 任选一款软件，按以下要求进行信息篡改:

  	+ [x] 基于WinDbg
  	
  	+ [x] 基于DLL注入，API hook技术
  	
  	  

## 实验说明

实验一为基于`WinDbg`、对特定的.txt文件进行字符串内容篡改：当用户对一个已创建的空文件输入`abcdefg`，篡改其为凯撒加密后的`defghij`。

实验二为基于`Message Hook`、对`Calculator.exe`进行`hook`,拦截键盘消息，实现键盘禁用的效果。



## 实验一

#### step1.创建目标文件

创建一个`.txt`类型的空文件（本实验目标文件路径文件为：F:\1.txt）

![](images\2.png)

#### step2.创建基于WinDbg的篡改脚本

创建一个`.txt`类型的空文件（本实验篡改脚本路径文件为：F:\2.txt），输入以下命令：

```c++
as /mu content poi(esp+0n24) //读取目标文件内容到缓冲区
.echo ${content}//输出读取的内容
.block{.if($scmp("${content}","abcdefg")==0){ezu poi(esp+0n24) "defghij";}.else{.echo "NotMatch!"}}//如果读取的内容为abcdefg,将对应指针所指内容改为defghij,否则输出"NotMatch!"
g//继续
```

![](images\1.png)

#### step3.WinDbg实现断点攻击

1.用`notepad`打开1.txt,在任务管理器中找到`notepad`的PID信息。

![](images\3.png)

2.打开WinDbg，打开Attach to Process，根据PID连接到notepad进程。

![](images\4.png)

3.在notepad中输入`bp kernelbase!writefile "$$<F:\2.txt"`设置断点，继续输入`g`进入debug。

![](images\5.png)

4.在1.txt尝试输入`ysdgdgg`，WinDbg结果如下：

![](images\6.png)

5.在1.txt尝试输入`abcdefg`，WinDbg结果如下：

![](images\7.png)

并发现1.txt内容发生变化，篡改成功！

![](images\8.png)

#### 



#### step 1. 编写生成.dll动态库的.cpp文件

`KeyboardProc()` 键盘回调函数，用于来判断键盘的操作，实现屏蔽的功能。

`GetModuleFileNameA()` 返回当前进程可执行或dll文件的完整路径，用于判别当前程序是否是notepad.exe。

`SetWindowsHookEx()` 用于拦截目标进程的消息到指定DLL中的导出函数。

`HookStart()` 、`HookStop()`是自定义的导出函数，用于实现启用和关闭钩子。

编写完成后生成动态链接库`hook.dll`文件。具体代码如下所示：

```C++
#include<stdio.h>
#include<windows.h>
#define HOOK_PROCESS_NAME "notepad.exe"

//初始化各个参数
HINSTANCE hInstance = NULL;
HHOOK hHook = NULL;
HWND hWnd = NULL;

//定义dll被加载时执行的动作
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID IpvReserved)
{
	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		//获得DLL被映射到进程地址空间内的虚拟地址
		hInstance = hinstDLL;
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

//键盘钩子函数
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
{
	char szPath[MAX_PATH] = { 0, };
	CHAR* p = NULL;
	//释放按键
	if (!(lParam & 0x80000000))
	{
		//获取当前程序可执行文件的路径名
		GetModuleFileNameA(NULL, szPath, MAX_PATH);
		//对字符串进行截断
		p = strrchr(szPath, '\\');
		//比较判断当前进程是否是Calculator.exe
		if (!_stricmp(p + 1, HOOK_PROCESS_NAME))
		{
			MessageBox(NULL, TEXT("hooked!!!"), TEXT("error"), MB_OK);
			return 1;
		}
	}
	//不是hook的程序，则传递到出去
	return CallNextHookEx(hHook, nCode, wParam, lParam);
}

//自定义的导出函数，开始勾取与结束勾取函数
extern "C" __declspec(dllexport) void HookStart()
{
	hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, hInstance, 0);
}

extern "C" __declspec(dllexport) void HookStop()
{
	if (hHook)
	{
		UnhookWindowsHookEx(hHook);
		hHook = NULL;
	}
}
```

#### step2.编写生成.exe应用程序的.cpp文件

设置变量获取Dll导出函数的地址，以便对函数进行调用。

编写完成后重新生成解决方案，生成`hook.exe`。具体代码如下所示：

```C++
#include<stdio.h>
#include<conio.h>
#include<windows.h>

#define DLL_NAME   "hook.dll"
#define HOOK_START "HookStart"
#define HOOK_STOP  "HookStop"

typedef void(*PFN_HOOKSTART)();
typedef void(*PFN_HOOKSTOP)();

int main()
{
    HMODULE DDll = NULL;
    PFN_HOOKSTART HookStart = NULL;
    PFN_HOOKSTOP  HookStop = NULL;
    char ch = 0;

    //加载dll
    DDll = LoadLibraryA(DLL_NAME);

    //获取导出函数的地址
    HookStart = (PFN_HOOKSTART)GetProcAddress(DDll, HOOK_START);
    HookStop = (PFN_HOOKSTOP)GetProcAddress(DDll, HOOK_STOP);

    //开始hook
    HookStart();
    printf("hook已开启!\n");
    //输入Q退出hook
    printf("按Q关闭hook!\n");
    while (1)
    {
        char h = _getch();
        _putch(h);
        if (h == 'Q')
            break;
    }
    //结束hook
    HookStop();

    //卸载dll
    FreeLibrary(DDll);
    return 0;
}
```

#### step3.运行程序

将刚刚生成的hook.dll文件放在与hook.exe文件同一目录下。

![](images\9.png)

先打开notepad.exe,再执行hook.exe。

在notepad界面尝试输入，效果如下。

![](images\10.png)